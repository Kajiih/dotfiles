# config.nu
#
# Installed by:
# version = "0.104.0"
#
# This file is used to override default Nushell settings, define
# (or import) custom commands, or run any other startup tasks.
# See https://www.nushell.sh/book/configuration.html
#
# This file is loaded after env.nu and before login.nu
#
# You can open this file in your default editor using:
# config nu
#
# See `help config nu` for more options

use std "path add"

const NU_COMPLETIONS_DIR = $nu.default-config-dir | path join completions
const NU_LIB_DIRS = [$NU_COMPLETIONS_DIR ($nu.default-config-dir | path join modules) ($nu.default-config-dir | path join submodules) ...$NU_LIB_DIRS]

# TODO:
# File issue on https://github.com/blindFS/topiary-nushell to break long lists, pipelines, etc

# === Env Vars ===

# --- Package Manager Binaries --- 
# https://reimbar.org/dev/nushell/
path add [
    "/usr/local/bin/" # System binaries (used at least on corp laptop)
    "/opt/homebrew/bin" # Homebrew binaries
    "~/.local/bin" # uv tools (and probably other) binaries
    "/opt/homebrew/opt/uutils-coreutils/libexec/uubin" # uutils-coreutils binaries
    # TODO: Improve this:
    "~/.manual_bin/clippy/" # Replaces digest on corp laptop
    "~/.lmstudio/bin" # LM Studio binaries
]
{{ if .useAndroidAutomotiveTools }}
source /Users/paquerot/.aae-toolbox/bin/aae.nu # aae tools
{{ end }}

# Source cargo env (and add binaries to path)
source $"($nu.home-path)/.cargo/env.nu"

# --- XDG config paths ---
$env.XDG_CONFIG_HOME = $env | get -o XDG_CONFIG_HOME | default ("~/.config" | path expand)
$env.XDG_DATA_HOME = $env | get -o XDG_DATA_HOME | default ("~/.local/share" | path expand)
$env.DOWNLOAD_DIR = "~/Downloads" | path expand

# --- Secrets ---
# TODO: Research secret zero/first secret to solve the problem of the first secret
use bws_secrets.nu
if (which bws | is-not-empty) {
    bws_secrets load-all
}

# Also load from local file for secrets not managed by the secret manager or in case you can't use it
source secrets.nu

# --- My Info ---
$env.EMAIL = "itskajih@gmail.com"
$env.USERNAME = "Kajih"

# --- Other --
$env.SHELL = "nu"
alias default_editor = {{ if eq .deviceUsage "professional" }}hx{{ else }}code{{ end }}
$env.config.buffer_editor = "{{ if eq .deviceUsage "professional" }}hx{{ else }}code{{ end }}"
# TODO(P1): Replace the template using resolve-alias-chain
# See: https://github.com/Kajiih/dotfiles/issues/1
$env.EDITOR = $env.config.buffer_editor

$env.config.show_banner = false
$env.config.edit_mode = 'vi'
$env.config.rm.always_trash = true

# Disable prompt from Nushell Because it is duplicated with that of Starship
$env.PROMPT_INDICATOR_VI_NORMAL = ""
$env.PROMPT_INDICATOR_VI_INSERT = ""
# Use cursor shape to differentiate instead
$env.config.cursor_shape.vi_insert = "blink_line"
$env.config.cursor_shape.vi_normal = "blink_block"

# === Plugins ===
const NU_PLUGIN_DIRS = [
    ($nu.current-exe | path dirname) # Core plugins in the same directory as nu's executable
    ~/.cargo/bin # 3rd party plugins
    ...$NU_PLUGIN_DIRS
]

# --- NUPM --- # Currently unstable # TODO: Check when stable
# # $env.NUPM_HOME = ($env.XDG_DATA_HOME | path join "nupm")
# $env.NUPM_HOME = "~/Library/Application Support/nushell/nupm" # TODO: Check if we keep that path
# $env.NU_LIB_DIRS = ($env.NUPM_HOME | path join "modules")
# path add ($env.NUPM_HOME | path join "scripts")

# --- PostgresQL ---  # TODO: Setup Postgres
# https://gitlab.com/HertelP/nu_plugin_nupsql
$env.config.plugins.nupsql.databases = [
    {
        # The name that is used to query the database (nuql query **name** query)
        host: localhost
        # Necessary connection information (except the password) 
        db: database
        user: postgres
        # Optional query alias to avoid typing often used statements
        query_alias: [
            {
                name: users
                query: "SELECT * FROM users;"
            }
        ]
    }
]

# === Tools ===
use std help

# --- Builtins ---
source init/custom_ls.nu
alias ll = ls -l
alias lsa = ls -a

# ls with filter by name ~= s
def lsf [s: string] {
    lsa | where name =~ $s
}

# -- open --
alias o = open

# https://www.nushell.sh/book/configuration.html#macos-keeping-usr-bin-open-as-open
# alias nu-open = open

# --- Customs ---
use resolve_alias_chain.nu resolve-alias-chain

use omnihelp.nu
alias h = omnihelp

# --- YouTube Downloader ---
$env.YOUTUBE_DOWNLOAD_DIR = $env.DOWNLOAD_DIR | path join youtube

# Download video/audio from YouTube using yt-dlp
alias ytdl = yt-dlp -P $env.YOUTUBE_DOWNLOAD_DIR

# -- Clipboard --
alias copy-to-clipboard = pbcopy

# Copy input to clipboard
# 
@category clipboard
@search-terms clipboard copy pbcopy
@example "Copy text to clipboard" { "Hello, World!" | to-clipboard }
@example "Strip ANSI codes and copy to clipboard" { "(ansi blue)Hello, World!(ansi reset)" | to-clipboard --strip }
def to-clipboard [
    --strip (-s) # Strip ANSI escape codes before copying
]: string -> nothing {
    let input = $in
    if $strip {
        $input | ansi strip | pbcopy
    } else {
        $input | pbcopy
    }
}
alias tc = to-clipboard


# -- SSH --

# ssh with an bash as environment's shell.
#
@category network
@search-terms ssh bash shell workaround corp-ssh-helper environment
@example "Connect to a remote host" { ssh_bash user@remote_host }
@example "Use with specific ssh arguments" { ssh_bash -v user@remote_host }
export def --wrapped ssh_bash [...args] {
    # Temporarily set the SHELL environment variable to /bin/bash
    with-env { SHELL: "/bin/bash" } {
        command ssh ...$args
    }
}
alias ssh = ssh_bash

{{- if eq .deviceUsage "professional" }}
# --- Tools for Professional Devices ---

# Returns true if gcert is valid for at least the specified duration
def is-gcert-valid [min_remaining = 60m] {
    (gcertstatus 
        --check_remaining=($min_remaining) 
        --quiet 
    | complete 
    | get exit_code) == 0
}

# Run a command after ensuring a valid gcert exists
# 
@category network
@search-terms gcert google authentication retry
@example "Run a command with gcert" { with-gcert { your-command-here } }
@example "Run ssh with gcert" { with-gcert { ssh user@remote_host } }
def with-gcert [action: closure] {
    if not (is-gcert-valid 60m) {
        gcert -prodssh
    }
    do $action
}

alias mystra = with-gcert { ssh mystra }
{{ end }}

#  --- Starship --
$env.STARSHIP_CONFIG = $env.XDG_CONFIG_HOME | path join starship config.toml
mkdir ($nu.data-dir | path join vendor/autoload)
starship init nu | save -f ($nu.data-dir | path join vendor/autoload/starship.nu)

# --- Carapace ---
$env.CARAPACE_BRIDGES = 'zsh,fish,bash,inshellisense' # optional
source ~/.cache/carapace/init.nu

let carapace_completer = {|spans: list<string>|
    carapace $spans.0 nushell ...$spans
    | from json
    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }
}

# --- Fish ---
let fish_completer = {|spans: list<string>|
    fish --command $"complete '--do-complete=($spans | str join ' ')'"
    | from tsv --flexible --noheaders --no-infer
    | rename value description
    | update value {
        if ($in | path exists) { $'"($in | str replace "\"" "\\\"")"' } else { $in }
    }
}

# --- atuin ---
# TODO(P1): Find a way to remove the star in the prompt added when sourcing atuin
# Issue: https://github.com/atuinsh/atuin/issues/2664
source ~/.local/share/atuin/init.nu

# --- Bat ---
# TODO? Install Nushell completion: https://gist.github.com/melMass/294c21a113d0bd329ae935a79879fe04 

# Use bat on man output
alias man = batman

alias b = bat
alias bh = bat --plain --language=help
alias bn = bat --number
alias bnl = bat --number --line-range
alias bp = bat --plain
alias bpl = bat --plain --line-range
alias bl = bat --line-range

# --- fd ---

# Preview fd results with bat
def fdx [s] {
    fd $s -X bat
}

# --- fzf ---
$env.FZF_DEFAULT_COMMAND = "fd --hidden --strip-cwd-prefix --exclude .git"
# alias fzf = fzf 
# Preview fzf result with bat
alias fzp = fzf --preview "bat --color=always --style=plain --line-range=:500 {}"

let fg = "#CBE0F0"
let bg = "#011628"
let bg_highlight = "#143652"
let purple = "#b192c9"
let blue = "#6cb6cd"
let cyan = "#2CF9ED"

$env.FZF_DEFAULT_OPTS = $" --color=,hl:($purple),hl+:($blue),prompt:($purple),pointer:($blue),marker:($cyan),spinner:($cyan),header:($cyan)" #fg:($fg),fg+:($fg),bg:($bg),info:($blue)bg+:($bg_highlight),

# Import the FZF keybindings module
source init/fzf_keybindings.nu

# --- Node/NPM ---
$env.NPM_CONFIG_USERCONFIG = $env.XDG_CONFIG_HOME | path join npm npmrc.ini

# --- Zoxide ---

# z to fuzzy cd
# zi to interactive cd with fzf
# https://github.com/ajeetdsouza/zoxide#configuration
source ~/.zoxide.nu

let zoxide_completer = {|spans: list<string>|
    $spans | skip 1 | zoxide query -l ...$in | lines | where {|x| $x != $env.PWD }
}

# --- Eza (better ls) ----

alias lz = eza --color=always --long --git --no-filesize --icons=always --no-time --no-user --no-permissions --group-directories-first --sort=type --sort=name
alias lza = lz -a
alias lzt = lz --tree --level=2
alias lztt = lz --tree
alias lzr = lz --recurse --level=2
alias lzrr = lz --recurse

# --- thefuck ---
# Workaround because repo is kinda dead: https://github.com/nvbn/thefuck/issues/1254
def fk [] {
    with-env {TF_ALIAS: "f" PYTHONIOENCODING: "utf-8"} {
        let cmd = thefuck (history | last 1 | get command.0)
        if ($cmd | is-not-empty) {
            nu -c $cmd
        }
    }
}

# --- ripgrep ---
$env.RIPGREP_CONFIG_PATH = $env.XDG_CONFIG_HOME | path join ripgrep config.sh
alias ripgrep = rg
alias rg = batgrep
alias rgi = rg -i  # Case insensitive
alias rga = rg -uuu
alias rgc = ripgrep --count

# Search in files found by ripgrep
def rgf [pattern: string ...rest] {
    ripgrep --files | ripgrep $pattern ...$rest
}

# --- Git ---
# Some from: https://github.com/nushell/nu_scripts/blob/main/aliases/git/git-aliases.nu

alias gs = git status
alias gll = git log --graph --all --pretty="format:%C(yellow)%h %C(white) %an  %ar%C(blue)  %D%n%s%n"
alias gl = gll --oneline
alias gad = git add
alias gada = git add --all
alias gps = git push
# git push + git push --tags
def gpst [] {git push; git push --tags}
alias gpl = git pull
alias gui = gitui

alias gc = git commit --message
alias gca = git commit --all --message

# Git commit with message (everything after the command is captured as message)
def gcm [...message] {
    git commit --message ($message | str join " ")
}

# Git commit ALL changes with message (everything after the command is captured as message)
def gcam [...message] {
    git commit --all --message ($message | str join " ")
}

# --- Chezmoi ---
alias ch = chezmoi
$env.DOTFILES_DIR = (chezmoi source-path | path dirname)
alias ched = default_editor $env.DOTFILES_DIR
$env.NUSHELL_DOTFILES_CONFIG = $env.DOTFILES_DIR | path join home dot_config nushell config.nu.tmpl
alias nuced = default_editor $env.DOTFILES_DIR --add $env.NUSHELL_DOTFILES_CONFIG
alias chd = chezmoi diff
alias chs = chezmoi status
alias chdr = chezmoi doctor
alias chap = chezmoi apply

# (BROKEN) Apply chezmoi changes and start new nu shell
# TODO(P1): Fix this
def chapn [] {
    chap | nu
}

# Chezmoi and git status (Chezmoi All Status)
def chas [] {
    print -n (ansi cyan) (ansi default_bold) "Chezmoi status:" (ansi reset) "\n"
    chezmoi status

    print -n (ansi cyan) (ansi default_bold) "Git status:" (ansi reset) "\n"
    git status
}

# -- Homebrew --
$env.HOMEBREW_BUNDLE_FILE = $env.XDG_CONFIG_HOME | path join homebrew Brewfile
{{- if eq .deviceUsage "professional" }}
$env.HOMEBREW_NO_AUTO_UPDATE = 1
{{- end }}

# --- OCR with tesseract ---

alias ocr = tesseract

# --- Topiary Nushell formatter ---
$env.TOPIARY_LANGUAGE_DIR = $env.XDG_CONFIG_HOME | path join topiary languages
$env.TOPIARY_CONFIG_FILE = $env.XDG_CONFIG_HOME | path join topiary languages.ncl

# For vscode extension:
# Check https://code.visualstudio.com/docs/supporting/faq#_resolving-shell-environment-fails and https://stackoverflow.com/questions/48595446/is-there-any-way-to-set-environment-variables-in-visual-studio-code to see if it's possible to source environment from nushell
# Apparently it's necessarily sourcing the env from then $SHELL defined in chsh: https://github.com/microsoft/vscode/issues/205321#issuecomment-1954415144
# Does this indeed mean that it sources necessarily from the login shell: https://code.visualstudio.com/docs/terminal/profiles#_why-are-there-duplicate-paths-in-the-terminals-path-environment-variable-andor-why-are-they-reversed-on-macos
# Track https://github.com/constneo/vscode-nushell-format/issues/1 for issue with space in command | path basename

# --- hyperfine ---

alias hyperfine = hyperfine --shell=nu
# TODO: Make it work on nu aliases, modules etc e.g. 
# hyperfine "bws_secrets get-token"
# hyperfine "lz"

# --- bandwhich ---

alias bandwhich = sudo bandwhich

# --- bottom ---

alias btm = btm --battery # wtf doesn't this work???

# --- grex ---

alias grex = grex --colorize

# --- Yazi ---
# y to open yazi, then q to quit and change CWD, or Q to quit without changing

# https://yazi-rs.github.io/docs/configuration/overview
def --env y [...args] {
    let tmp = (mktemp -t "yazi-cwd.XXXXXX")
    yazi ...$args --cwd-file $tmp
    let cwd = (open $tmp)
    if $cwd != "" and $cwd != $env.PWD {
        cd $cwd
    }
    rm -fp $tmp
}
# TODO: Map ctrl-o to opening yazi

def --env zy [...args] {
    zi
    y
}

# --- onefetch ---
alias onefetch = onefetch --nerd-fonts --no-color-palette
# Short version showing only high level info
alias onefetch-s = onefetch --disabled-fields dependencies authors contributors url commits churn lines-of-code size license --no-title --no-art
# expensive fields (given some tiny benchmarks with cache warmup):
# - pending
# - license
# - size
# also: 
# - title


# --- Custom utils ---
use squeeze.nu

def git-status-short [] {
    git -c color.ui=always status | squeeze
}

def --env fzg [ --from-home (-a)] {
    if $from_home { cd $env.HOME }

    fd -u --type directory --glob '.git' --exclude '/.*'
    | lines
    | each { path dirname }
    | str join "\n"
    # | fzf --preview "tree -C {} --gitignore | head -n 80"
    # | fzf --preview "onefetch {} --type prose programming markup data"
    # | fzf --preview 'nu -c "lz --tree --git-ignore {} | head -n 80"' # TODO: Check why we can't use aliases in fzf preview; can try this: https://github.com/junegunn/fzf/issues/1374
    # | fzf --preview "(try {(onefetch {} --type prose programming markup data --disabled-fields dependencies authors url  churn lines-of-code size license --no-title --no-art --no-color-palette)  + `\n`} catch {''}) + (eza {} --color=always --git --git-ignore --no-filesize --icons=always --no-time --no-user --no-permissions --group-directories-first --sort=type --sort=name) | head -n 80"  # TODO: Create preview command file
    | fzf --preview "(try {(onefetch {} --type prose programming markup data  --no-title --no-art --no-color-palette --disabled-fields license size pending)} catch {(eza {} --color=always --git --git-ignore --no-filesize --icons=always --no-time --no-user --no-permissions --group-directories-first --sort=type --sort=name --tree --level 3) | head -n 80}) " # TODO: Create preview command file
    | cd $in
    # | cd ($base_dir | path join $in)  # TODO: Report that produces a weir behavior in the shell after that

    onefetch --type prose programming markup data
    git-status-short
    # gitui
    # return gstat  # Check why we can't use plugins here
    # return  # early return to stop fd
}

# --- zellij ---
alias zj = zellij

# --- Copier ---
$env.COPIER_SETTINGS_PATH = $env.XDG_CONFIG_HOME | path join copier settings.yml

# === Completions ===
# TODO: Check if it's possible to autoload completion modules using $nu.user_autoload_dirs
use completions *

# Update the completions module exporting every module inside $NU_COMPLETIONS_DIR
# To use after adding completions
def update_completions_module [] {
    let module_path = ($NU_COMPLETIONS_DIR | path join mod.nu)
    rm $module_path --force

    ls $NU_COMPLETIONS_DIR
    | where name ends-with ".nu"
    | get name
    | each {|file| $"export use ($file | path basename) *" }
    | str join "\n"
    | save $module_path -f
}

use init/external_completers.nu create-external-completer

let external_completer = create-external-completer --carapace-completer $carapace_completer --fish-completer $fish_completer --zoxide-completer $zoxide_completer

# --- External Completers --

# Update config
$env.config.completions.external = {
    enable: true
    completer: $external_completer
}

# === Theming ===
# https://www.nushell.sh/book/coloring_and_theming.html#understanding-ls-colors

# --- LS Colors ---
# Using Vivid: https://github.com/sharkdp/vivid
# $env.LS_COLORS = (vivid generate ayu)

# Auto imported from https://github.com/trapd00r/LS_COLORS
let ls_colors_file = $nu.default-config-dir | path join data lscolors.sh
$env.LS_COLORS = open $ls_colors_file | str substring 11..-20

# === Keybindings ===
# https://www.nushell.sh/book/line_editor.html#keybindings
$env.config.keybindings ++= [
    # TODO: Check why it doesn't work with any Shift + Enter | Cmd + Enter ... (file issue)
    # {
    #     name: insert_newline_shift
    #     modifier: Shift
    #     keycode: Enter
    #     mode: [vi_insert vi_normal]
    #     event: { edit: InsertNewline }
    # }
    {
        name: abbr
        modifier: control
        keycode: space
        mode: [emacs vi_normal vi_insert]
        event: [
            {send: menu name: abbr_menu}
            {edit: insertchar value: ' '}
        ]
    }
]

$env.config.menus ++= [
    {
        name: abbr_menu
        only_buffer_difference: false
        marker: "ðŸ‘€ "
        type: {
            layout: columnar
            columns: 1
            col_width: 20
            col_padding: 2
        }
        style: {
            text: green
            selected_text: green_reverse
            description_text: yellow
        }
        source: {|buffer position|
            scope aliases
            | where name == $buffer
            | each {|elt| {value: $elt.expansion} }
        }
    }
]


# === Google Specific Device Config ===
{{- if .isGoogleSpecific }}
alias gemini = /google/bin/releases/gemini-cli/tools/gemini
alias colab = /google/bin/releases/grp-ix-team/rapid/colab-cli/cli.par  # TODO: P1 - Test this
alias tx = tmx2
if $nu.is-interactive and (gcertstatus --check_remaining=60m | complete | get exit_code | $in != 0) {
    gcert -s
}

# --- Colab Auth ---

# Timestamp marker file path
let colab_auth_marker = ($env.XDG_DATA_HOME | path join "colab_auth_marker")

# Wrapper to run colab auth and update the timestamp
def update-colab-auth [] {
    ^/google/bin/releases/colaboratory/public/tools/authorize_colab
    # Create/update a marker file in your data directory
    touch $colab_auth_marker
}

# Return true if the colab auth is valid
def is-colab-auth-valid [] {
    let threshold = 90day 
    return (not ($colab_auth_marker | path exists) or ((ls $colab_auth_marker | get 0.modified) + $threshold < (date now)))
}

# Warn the user if colab auth is not valid.
def check-colab-auth-validity [] {
    if not is-colab-auth-valid() {
    print $"(ansi yellow_bold)âš ï¸  Colab authorization may be expired \(> 2 months\).(ansi reset)"
    print $"Run (ansi cyan)update-colab-auth(ansi reset) to refresh."
    }
}



# --- Workspace tools ---

# Copy file across piper/fig/jj workspaces
# 
# Source and destination paths are relative to google3/, as obtained by "Copy Path" in cider
# Ref: https://yaqs.corp.google.com/eng/q/6441503164976857088
# TODO: P2 - Test this
@category filesystem
@search-terms google copy workspace
@example "Copy a file from one workspace to another" { copy-across-workspaces "my_source_workspace" "path/to/source/file.ext" "my_dest_workspace" "path/to/dest/file.ext" }
def --wrapped copy-across-workspaces [source_workspace: string, source_path: string, dest_workspace: string, dest_path: string, ...args: string]: [nothing -> nothing] {
    let username = (whoami)
    # cp /google/src/cloud/<your username>/<your src workspace>/google3/<your/file.ext> /google/src/cloud/<your username>/<your dst workspace>/google3/<your/file.ext> 
    let full_source_path = $"/google/src/cloud/($username)/($source_workspace)/google3/($source_path)"
    let full_dest_path = $"/google/src/cloud/($username)/($dest_workspace)/google3/($dest_path)"
    cp $full_source_path $full_dest_path ...$args
}


# --- Blaze tools ---
alias blest = blaze test :all
alias blesta = blaze test ...:all

# --- Build Cleaner ---
alias bclean = build_cleaner :all
alias bcleana = build_cleaner ...:all
{{ end }}
